#!/usr/bin/env python3
"""
PCD analysis:
- Bootstrap confidence intervals
- Outlier detection across seeds
- Per-group t-test against 0
- LaTeX table export
- Diagnostic plots

Input:
    results_multiseed_full.csv
      (generated by the full multi-seed / multi-compressor experiment script)

Output:
    results_bootstrap.csv
    results_with_stats.csv
    latex_table_r_PhIIa.tex
    fig_<ensemble>_r_PhIIa.png
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
from math import sqrt
from scipy.stats import ttest_1samp


# -------------------------------------------------
# Helpers
# -------------------------------------------------

def bootstrap_ci(data, n_boot=2000, ci=95):
    """Return (mean, (ci_low, ci_high)) via bootstrap on the sample mean."""
    data = np.asarray(data)
    if len(data) == 0:
        return np.nan, (np.nan, np.nan)
    boot_means = np.random.choice(data, (n_boot, len(data)), replace=True).mean(axis=1)
    lower = np.percentile(boot_means, (100 - ci) / 2)
    upper = np.percentile(boot_means, 100 - (100 - ci) / 2)
    return float(np.mean(data)), (float(lower), float(upper))


def format_ci(mean, ci):
    return f"{mean:+.3f} [{ci[0]:+.3f}, {ci[1]:+.3f}]"


def latex_escape(s):
    return s.replace("_", "\\_")


def detect_outliers(vals, z_thresh=2.0):
    """
    Return (outlier_mask, outlier_frac).
    Flags any |val - mean| > z_thresh * std.
    If std == 0, there are no outliers unless all vals differ from mean (then 0 anyway).
    """
    vals = np.asarray(vals)
    if len(vals) == 0:
        return np.zeros_like(vals, dtype=bool), np.nan
    mu = np.mean(vals)
    sd = np.std(vals, ddof=1)  # sample std
    if sd == 0:
        mask = np.zeros_like(vals, dtype=bool)
        return mask, 0.0
    z = np.abs((vals - mu) / sd)
    mask = z > z_thresh
    frac = mask.mean()
    return mask, frac


def ttest_against_zero(vals):
    """
    Two-sided t-test of H0: mean(vals) == 0.
    Returns (mean, pval, n).
    We treat per-seed correlation values as i.i.d. replicates, which is exactly
    what Claude wants for the "multi-seed replication" claim.
    """
    vals = np.asarray(vals)
    if len(vals) == 0:
        return np.nan, np.nan, 0
    tstat, pval = ttest_1samp(vals, 0.0)
    return float(vals.mean()), float(pval), len(vals)


# -------------------------------------------------
# Main
# -------------------------------------------------

def main():
    src = Path("results_multiseed_full.csv")
    if not src.exists():
        print("Error: results_multiseed_full.csv not found. Please run the full experiment script first.")
        return

    df = pd.read_csv(src)
    print(f"Loaded {len(df)} rows from {src}")

    # We will summarise the main metric of interest (r_PhIIa),
    # but we will also compute stats for the others to satisfy curiosity.
    metrics = ["r_PhI", "r_PhIIa", "r_PhIIb", "r_Rg", "r_NND", "r_Var"]

    # Group key: ensemble, Δx, compressor
    groups = ["ensemble", "Δx", "compressor"]

    rows_boot = []
    rows_stats = []

    for (ens, dx, comp), g in df.groupby(groups):

        # Per-metric bootstrap CIs and outlier flags
        for m in metrics:
            vals = g[m].dropna().values

            # Bootstrap CI
            mean_boot, (ci_lo, ci_hi) = bootstrap_ci(vals, n_boot=2000, ci=95)

            # Outlier fraction (seed-level stability diagnostic)
            outmask, ofrac = detect_outliers(vals, z_thresh=2.0)

            # Simple t-test of correlation against 0
            # (we'll only highlight for Phase IIa in print/LaTeX, but we compute all here)
            mean_direct, pval_direct, n_direct = ttest_against_zero(vals)

            rows_boot.append({
                "ensemble": ens,
                "Δx": dx,
                "compressor": comp,
                "metric": m,
                "mean_boot": mean_boot,
                "ci_low": ci_lo,
                "ci_high": ci_hi,
                "n": len(vals),
            })

            rows_stats.append({
                "ensemble": ens,
                "Δx": dx,
                "compressor": comp,
                "metric": m,
                "n": n_direct,
                "mean_direct": mean_direct,
                "p_value_vs_0": pval_direct,
                "outlier_frac_>2sd": ofrac,
            })

    out_boot = pd.DataFrame(rows_boot)
    out_stats = pd.DataFrame(rows_stats)

    out_boot.to_csv("results_bootstrap.csv", index=False)
    out_stats.to_csv("results_with_stats.csv", index=False)

    print("Wrote results_bootstrap.csv")
    print("Wrote results_with_stats.csv")

    # -------------------------------------------------
    # Pretty console summary for the main metric r_PhIIa
    # -------------------------------------------------
    print("\n=== Phase IIa summary (Φ_b vs Phase IIa compressed size) ===")
    main_metric_boot = out_boot[out_boot["metric"] == "r_PhIIa"]
    main_metric_stats = out_stats[out_stats["metric"] == "r_PhIIa"]

    # Merge CI + stats for nicer printing
    merged = pd.merge(
        main_metric_boot,
        main_metric_stats[["ensemble", "Δx", "compressor", "n", "mean_direct", "p_value_vs_0", "outlier_frac_>2sd"]],
        on=["ensemble", "Δx", "compressor", "n"],
        how="inner"
    )

    for (ens, dx), block in merged.groupby(["ensemble", "Δx"]):
        print(f"\nEnsemble {ens}, Δx={dx:g}")
        for _, row in block.iterrows():
            mean_ci = format_ci(row["mean_boot"], (row["ci_low"], row["ci_high"]))
            print(
                f"  {row['compressor']:>5} "
                f"| r_PhIIa = {mean_ci} "
                f"| n={int(row['n'])} "
                f"| outliers>{2}σ: {row['outlier_frac_>2sd']*100:.1f}% "
                f"| p(r=0)={row['p_value_vs_0']:.2e}"
            )

    # -------------------------------------------------
    # Generate LaTeX table for Phase IIa
    # -------------------------------------------------
    tex_lines = []
    tex_lines.append("\\begin{table}[h!]")
    tex_lines.append("\\centering")
    tex_lines.append("\\small")
    tex_lines.append("\\begin{tabular}{l l l r r r r r}")
    tex_lines.append("\\toprule")
    tex_lines.append("Ensemble & $\\Delta x$ & Compressor & Mean $r_{\\text{PhIIa}}$ & 95\\% CI low & 95\\% CI high & Outliers (\\%) & $p(r=0)$\\\\")
    tex_lines.append("\\midrule")

    for (ens, dx), block in merged.groupby(["ensemble", "Δx"]):
        for _, row in block.iterrows():
            tex_lines.append(
                f"{latex_escape(ens)} & {dx:g} & {latex_escape(row['compressor'])} "
                f"& {row['mean_boot']:+.3f} & {row['ci_low']:+.3f} & {row['ci_high']:+.3f} "
                f"& {row['outlier_frac_>2sd']*100:.1f}\\% "
                f"& {row['p_value_vs_0']:.1e}\\\\"
            )
        tex_lines.append("\\midrule")

    tex_lines.append("\\bottomrule")
    tex_lines.append("\\end{tabular}")
    tex_lines.append("\\caption{Per-ensemble, per-quantization, per-compressor statistics for $r_{\\text{PhIIa}}$ (correlation between $\\Phi_b$ and Phase IIa compressed size). We report bootstrap 95\\% CIs across 50 random seeds, the fraction of seeds flagged as $>2\\sigma$ outliers, and a two-sided $t$-test $p$-value for the null hypothesis $r=0$.}")
    tex_lines.append("\\label{tab:phase2a_stats}")
    tex_lines.append("\\end{table}")

    Path("latex_table_r_PhIIa.tex").write_text("\n".join(tex_lines))
    print("\nWrote latex_table_r_PhIIa.tex")

    # -------------------------------------------------
    # Diagnostic plots: mean ± CI vs Δx, per ensemble
    # -------------------------------------------------
    for ens in df["ensemble"].unique():
        fig, ax = plt.subplots(figsize=(7, 4))
        block = merged[merged["ensemble"] == ens]

        # To keep ordering of legend consistent:
        compressors = sorted(block["compressor"].unique())

        for comp in compressors:
            d = block[block["compressor"] == comp].sort_values("Δx")
            ax.errorbar(
                d["Δx"],
                d["mean_boot"],
                yerr=[d["mean_boot"] - d["ci_low"], d["ci_high"] - d["mean_boot"]],
                label=comp,
                marker="o",
                capsize=3,
                linestyle="-"
            )

        ax.set_title(f"{ens}: $r_{{\\mathrm{{PhIIa}}}}$ vs. $\\Delta x$")
        ax.set_xlabel("$\\Delta x$")
        ax.set_ylabel("Mean correlation ±95% CI")
        ax.set_xscale("log")
        ax.set_ylim(-1.05, 1.05)
        ax.legend(title="Compressor")
        fig.tight_layout()
        out_path = Path(f"fig_{ens}_r_PhIIa.png")
        fig.savefig(out_path, dpi=200)
        plt.close(fig)

    print("\nWrote per-ensemble plots: fig_<ensemble>_r_PhIIa.png")

    print("\nAnalysis complete. These outputs are what we cite in the paper.")
    print("Key files:\n  results_with_stats.csv\n  latex_table_r_PhIIa.tex\n  fig_<ensemble>_r_PhIIa.png")

# -------------------------------------------------
# Entry point
# -------------------------------------------------

if __name__ == "__main__":
    main()
